Cooperating with RxJS:

- Signals and RxJS empower Angular applications with reactive capabilities. These libraries can 
    complement each other to provide reactivity while using the benefits of the Angular framework. 

- Signals was not built to replace RxJS but to provide an alternate reactive approach to developers 
    with the following additional characteristics:
    ‚Ä¢ Fine-grained reactivity
    ‚Ä¢ Imperative programming
    ‚Ä¢ Improved usage of the change detection mechanism

- However, there are core parts in the Angular framework that still use RxJS and observables, such 
    as the HTTP client and the router. Additionally, many developers prefer the declarative
    approach that the RxJS library provides out of the box.

- Angular Signals provides a built-in API to cooperate with RxJS and observables. The signals API 
    provides a function that can convert an observable into a signal:

1) Open the product-list.component.ts file and import the inject and toSignal artifacts:

        import { Component, üëâinject } from '@angular/core';
    üëâ import { toSignal } from '@angular/core/rxjs-interop';

    -> The @angular/core/rxjs-interop npm package includes all the utility methods for handling
        signal and observable cooperation. The toSignal function can convert an observable 
        into a signal.

2) Create the following signal in the ProductListComponent class:

        products = toSignal(inject(ProductsService).getProducts(), {
            initialValue: []
        });
    
    -> We pass two parameters in the toSignal function: the observable we want to convert 
        and an initial value optionally.
    -> In this case, we pass the getProducts method of the ProductService class that returns an
        observable, and we also set the initial value of the signal to an empty array.

3) Open the product-list.component.html file and modify its contents as follows:

        @if (products().length > 0) {
            <h1>Products ({{ products().length }})</h1>
        }

        <ul class = "pill-group">
        @for (product of products() | sort; track product.id) {
            <li class="pill" (click)="selectedProduct = product">
            @switch (product.title) {
                @case ('Keyboard') {‚å®Ô∏è}
                @case ('Microphone') {üéôÔ∏è}
                @default {üè∑Ô∏è}
            }
            {{product.title}}
            </li>
        }
        @empty {
            <li class = "pill">No products available</li>
        }
        </ul>

        <app-product-detail
            [product]="selectedProduct"
            (added)="onAdded()">
        </app-product-detail>
    
    -> In the preceding template, we removed the top @if block and converted the products 
        property into a signal.
    -> We do not need the async pipe because signals subscribe automatically to an observable.

4) To further clean up our component, we can remove any code that is related to the async 
    pipe and observables since it is no longer needed. The resulting product-list.component.ts
    file should be the following:

        import { Component, inject } from '@angular/core';
        import { Product } from '../product'; // importing interface
        import { ProductDetailComponent } from '../product-detail/product-detail.component';
        import { SortPipe } from '../sort.pipe';
        import { ProductsService } from '../products.service';
        import { toSignal } from '@angular/core/rxjs-interop';


        @Component({
            selector: 'app-product-list',
            imports: [ProductDetailComponent, SortPipe],
            templateUrl: './product-list.component.html',
            styleUrl: './product-list.component.css',
            providers: [ProductsService]
            })
            export class ProductListComponent {

            // products: Product[] = [];
            products = toSignal(inject(ProductsService).getProducts(), {
                initialValue: []
            });

            selectedProduct: Product | undefined;

            onAdded() {
                alert(`${this.selectedProduct?.title} added to the cart!`);
            }
        }

5) Run the application using ng serve and observe that the application output displays the product
    list.

- The preceding snippet looks much simpler. Angular signals improve the developer experience 
    and ergonomics in addition to the performance of our applications.
