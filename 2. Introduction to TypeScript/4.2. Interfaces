Interfaces:

- An interface is a code contract that defines a particular schema. Any artifacts like classes and 
    functions implementing an interface should comply with this schema.
- Interfaces are beneficial when we want to enforce strict typing on classes generated by factories or
    when we define function signatures to ensure that a particular typed property is found in the payload.

📝
Interfaces disappear during transpilation and are not included in the final JavaScript code.

-  In the following snippet, we define an interface for managing products:

        interface Product {
            name: string;
            price: number;
            getCategories: () => string[];
        }
    
    -> An interface can contain properties and methods.

📝
Interfaces are the recommended approach when working with data from a backend API or other source.

- A class can use an interface by adding the implements keyword and the interface name in the class
    declaration:

        class Keyboard implements Product {
            name: string = "Keyboard";
            price: number = 20;
            
            getCategories(): string[] {
                return ["Computing", "Peripherals"];
            }
        }
    
    -> the Keyboard class must implement all members of the Product interface; otherwise, TypeScript
        will throw an error.
    -> If we do not want to implement an interface member, we can define it as optional using the ?
        character:

        interface Product {
            name: string;
            price: number;
            getCategories: () => string[];
            description?: string;
        }

- We can also use interfaces to change the type of a variable from one type to another, called type 
    casting. Type casting is useful when working with dynamic data or when TypeScript cannot infer the
    type of a variable automatically.
    In the following code, we instruct TypeScript to treat the product object as a Product type:

        const product = {
            name: 'Keyboard',
            price: 20
        } as Product;

        -> However, type casting should be used with caution. In the preceding snippet, we intentionally 
            omitted to add the getCategories method, but TypeScript did not throw an error. 

📝
It is recommended to avoid type casting if possible and define types explicitly.

- Interfaces can be combined with generics to provide a general code behavior regardless of the 
    data type.
_________________________________________________________________________________________________________________

Generics:

- Generics are used when we want to use dynamic types in other TypeScript artifacts, such as methods.
- Suppose that we want to create a function for saving a Product object in the local storage of the 
    browser:

        function save(data: Product) {
            localStorage.setItem('Product', JSON.stringify(data));
        }
    
    -> In the preceding code, we explicitly define the data parameter as a Product.
    -> If we also want to save Keyboard objects, we should modify the save method as follows: 

        function save(data: Product | Keyboard) {
            localStorage.setItem('Product', JSON.stringify(data));
        }

- However, the preceding approach does not scale well if we would like to add other types in the 
    future. Instead,
    1) we can use generics to let the consumer of the save method decide upon the data type passed:

        function save<T>(data: T) {
            localStorage.setItem('Product', JSON.stringify(data));
        }
    
    -> the type of T is not evaluated until we use the method.
    -> We use T as a convention to define generics, but you can also use other letters.

    2) We can execute the save method for a Product object as follows:

        save<Product>({
            name: 'Microphone',
            price: 45,
            getCategories: () => ['Peripherals', 'Multimedia']
        });

- If we would like to use more generics in our save method, we could use different letters, such as:
        
        function save<T, P>(data: T, obj: P) {
            localStorage.setItem('Product', JSON.stringify(data));
        }

- Generics are often used in collections because they have similar behavior, regardless of the type.
___________________________________________________________________________________________________________________

Utility types:

- Utility types are types that help us to derive new types from existing ones.
- The Partial type is used when we want to create an object from an interface where all its properties
    are optional. In the following snippet, we use the Product interface to declare a trimmed 
    version of a product:

        const mic: Partial<Product> = {
            name: 'Microphone',
            price: 67
        };
    
    -> here we can see that the mic object does not contain the getCategories method.
    -> Alternatively, we could use the Pick type, which allows us to create an object from a 
        subset of interface properties:

        type Microphone = Pick<Product, 'name' | 'price'>;
        const microphone: Microphone = {
            name: 'Microphone',
            price: 67
        };

- Some languages, such as C#, have a reserved type when defining a key-value pair object or dictionary,
    as it is known. In TypeScript, if we want to define such a type, we can use a Record type:

        interface Order {
            products: Record<string, number>;
        }

        -> The preceding snippet defines the product name as a string and the quantity as a number

- You can find more utility types at https://www.typescriptlang.org/docs/handbook/utilitytypes.html.